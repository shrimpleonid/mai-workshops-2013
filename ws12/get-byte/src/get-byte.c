/**
 * @section Описание
 *
 *      Программа выводит значения байта заданного числа.
 *      Со стандартного потока ввода (stdin) считывается входное число 
 *      и номер байта, который нужно вывести. Отчет ведется от нуля.
 *      На стандартный поток вывода (stdout) выводится значение искомого байта.
 *      На стандартный поток ошибок выводится отладочная информация: 
 *          * входное число в двоичном представлении;
 *          * входное число после двоичного сдвига на номер бита,
 *            т.е. `<номер байта> * 8`.
 *            Тоже в двоичном представлении;
 *          * двоичное представление маски, по которой выделяется байт;
 *          * двоичное представление, искомого байта.
 *      Размер входного числа должен быть не более размера типа `unsigned int`,
 *      вашего компилятора. Программа проверялась на gcc x86_64.
 *      Размер `unsigned int` составлял четыре байта (32 бита).
 *      
 *      @subsection Пример
 *      
 *          $> gcc ./get-byte.c -Wall  -pedantic -std=c89
 *          $> ./a.out 
 *          10 0
 *          debug: input    = 00000000000000000000000000001010 [32]
 *          debug: shifted  = 00000000000000000000000000001010 [32]
 *          debug: mask     = 00000000000000000000000011111111 [32]
 *          debug: byte     = 00000000000000000000000000001010 [32]
 *          debug: byte     = 00001010 [8]
 *          10
 *          $> ./a.out 2> /dev/null
 *          10 0
 *          10
 *          $> ./a.out 
 *          -10 0
 *          debug: input    = 11111111111111111111111111110110 [32]
 *          debug: shifted  = 11111111111111111111111111110110 [32]
 *          debug: mask     = 00000000000000000000000011111111 [32]
 *          debug: byte     = 00000000000000000000000011110110 [32]
 *          debug: byte     = 11110110 [8]
 *          246
 *          $> ./a.out 2> /dev/null
 *          2147483647 3
 *          127
 *          $> ./a.out 1> /dev/null
 *          2147483647 3
 *          debug: input    = 01111111111111111111111111111111 [32]
 *          debug: shifted  = 00000000000000000000000001111111 [32]
 *          debug: mask     = 00000000000000000000000011111111 [32]
 *          debug: byte     = 00000000000000000000000001111111 [32]
 *          debug: byte     = 01111111 [8]
 *          $> 
 * 
 *  @authors    Никитин Илья Константинович (преп. каф. 806 МАИ) <w@w-495.ru>
 *  @version    1.0
**/

/*
 * Подключаем заголовочный файл стандартного ввода-вывода 
 * (STanDart Input-Output) для использования getchar, putchar, scanf, printf.
 */
#include <stdio.h>

/**
 * @fn  Возвращает бит числа `input` под номером `num`.
 *      Отсчет ведется от нуля.
 * 
 * @param   input   входное число;
 * @param   num     номер байта.
 **/ 
int get_byte(unsigned int input, unsigned short num); 

/**
 * @fn  Выводит на поток ошибок число `input` в двоичном представлении.
 *      В этой программе нужна исключительно для отладки.
 * 
 * @param   str     строка сопровождения; 
 * @param   input   входное число `unsigned int`.
 **/ 
void debug_print_binary_long(const char* str, unsigned int input);

/**
 * @fn  Выводит на поток ошибок число `input` в двоичном представлении.
 *      В этой программе нужна исключительно для отладки.
 * 
 * @param   str     строка сопровождения; 
 * @param   input   входное число типа `unsigned short`.
 **/ 
void debug_print_binary_byte(const char* str, unsigned short input);

    
int main(){
    /**
     * @var Входное число, для которого надо вывести бит.
     */ 
    unsigned int input = 0;
    
    /**
     * @var Номер бита, который нужно вывести. Отсчет от нуля.
     */ 
    unsigned short num = 0;
    
    /**
     * @var Бит, который мы будем выводить.
     *      Изначально присваиваем невозможное значение,
     *      Чтобы быстро выловить ошибку, если у нас такая случится.
     */ 
    unsigned short byte = 0;

    if(scanf("%u", &input) != 1){
        /*
         *  Защита от дурака.
         *  Если на вход подается что-то неприличное,
         *  то на стандартный поток (файл) ошибок выводим сообщения об ошибке.
         */
        fprintf(stderr, "error: %u is not integer number.\n", input);
        return 1;
    }
    if(scanf("%hu", &num) != 1){
        /*
         *  Защита от дурака.
         *  Если на вход подается что-то неприличное,
         *  то на стандартный поток (файл) ошибок выводим сообщения об ошибке.
         */
        fprintf(stderr, "error: %hu is not number of byte.\n", num);
        return 1;
    }
    /*
     * Определяем бит. Обратите внимание,
     * что отсчет битов идет не от единицы, а от нуля.
     */
    byte = get_byte(input, num);
    printf("%hu\n", byte);
    return 0;
}

/**
 * @fn  Возвращает байт числа `input` под номером `num`.
 *      Отсчет ведется от нуля.
 * 
 * @param   input   входное число;
 * @param   num номер байта;
 **/ 
int get_byte(unsigned int input, unsigned short num){
    /**
     * @var Число бит, на которое мы хотим сдвинуть входное число.
     */ 
    unsigned short numbit =  num * 8;
    
    /**
     * @var Битовая маска. 
     *      Будем накладывать на число (применять побитовое умножение), 
     *      чтобы получить байт. Как мы получили эту маску:
     *          1 << 8          = 256 = "100000000";
     *          (1 << 8) - 1    = 255 = "011111111";
     *      Т.о., можно было бы зашить `mask = 255L`.
     *      Но для наглядности, оставим вычисления маски.
     */ 
    unsigned short mask = (1 << 8) - 1;
    
    /**
     * @var Переменная для хранения числа, сдвинутого на `numbit` бит.
     */ 
    unsigned int shifted = 0;
    
    /**
     * @var Переменная для хранения полученного байта.
     */ 
    unsigned short byte = 0;
    
    /*
     * Посмотрим, как выглядит наше число в двоичном представлении.
     * Это нужно только для отладки
     */ 
    debug_print_binary_long("input\t= ", input);
    /*
     * Двоичный сдвиг числа `input` на `num` бит влево 
     * (по сути, `num` раз разделили на `2`).
     * Как альтернатива:
     *      Сдвигать можно не число влево, а полученную маску вправо.
     */ 
    shifted = (input >> numbit);
    /*
     * Посмотрим в двоичном представлении это же число после сдвига.
     * Это нужно только для отладки.
     */ 
    debug_print_binary_long("shifted\t= ", shifted);
    
    /*
     * Посмотрим в двоичном представлении на двоичную маску.
     * Это нужно только для отладки.
     */ 
    debug_print_binary_long("mask\t= ", mask);
    /**
     * Применяем побитовое умножение `битовое И` для исходного числа 
     * и 255. Таким образом выделяем нужные бит.
     * Суффикс `L` у числа говорит компилятору, 
     * что мы работаем с типом `unsigned int`.
     */ 
    byte = shifted & mask;
    
    /*
     * Посмотрим в двоичном представлении на полученный байт,
     * выровненный по размеру к типу данных входного числа.
     * Это может быть нужно не только для отладки,
     * но в данном случае от нас не требуют выводит бинарное 
     * представление байта.
     */ 
    debug_print_binary_long("byte\t= ", byte);
    
    /*
     * Посмотрим в двоичном представлении на полученный байт,
     * так чтобы он выглядел как байт (8 бит).
     */ 
    debug_print_binary_byte("byte\t= ", byte);
    
    return byte;
}

/**
 * @fn  Выводит на поток ошибок число `input` в двоичном представлении.
 *      В этой программе нужна исключительно для отладки.
 * 
 * @param   input   входное число;
 * @param   width   ширина выводимого числа;
 *                  Этот аргумент нужен, чтобы дополнять выходное число 
 *                  ведущеми нулями, до нужного размера.
 *                  Например `debug_util_print_binary(2, 4)` напечатает `0010`.
 **/ 
void debug_util_print_binary(unsigned int input, unsigned short width){
    /*
     * Получаем разряд числа `input` в системе счисления `2`.
     */ 
    unsigned short digit = input % 2;
    

    /*
     * Условие остановки рекурсии.
     */ 
    if(!input){
        unsigned short  i;
        /*
         * Печатаем ведущие нули.
         * Каждый предыдущий шаг рекурсии уменьшал `width` на единицу,
         * т.к. к выходному числу добавлялось по разряду.
         * Теперь мы выводим столько нулей, сколько необходимо,
         * до дополнения до ширины `width`.
         */ 
        for(i = 0; i < width; ++i)
            fprintf(stderr, "0");
    }
    else{
        /*
        * Рекурсивно вызываем эту же функцию,
        * Параметр `input` становится в `2` раза меньше, 
        * а параметр `width` уменьшаем на 1, 
        * если он был положительным (тут используется тренарный оператор).
        * Как результат возвращает предыдущие разряды числа.
        */
        debug_util_print_binary(input >> 1, (width) ? (width - 1) : 0);
        fprintf(stderr, "%hu", (unsigned short)digit);
    }
}

/**
 * @fn  Выводит на поток ошибок число `input` в двоичном представлении.
 *      В этой программе нужна исключительно для отладки.
 *      Вызывает функцию `debug_util_print_binary`, и добавляет к выводу,
 *      сопровождающую строку. По задумке в этой строке должно выводиться,
 *      описание, остального вывода.
 *      
 * @param   str     строка сопровождения; 
 * @param   input   входное число;
 * @param   width   ширина выводимого числа.
 **/
void debug_string_print_binary(
    const char* str, unsigned int input, unsigned short width
){
    fprintf(stderr, "debug: ");
    fprintf(stderr, str);
    debug_util_print_binary(input, width);
    fprintf(stderr, " [%hu]\n", width);
}

/**
 * @fn  Выводит на поток ошибок число `input` в двоичном представлении.
 *      В этой программе нужна исключительно для отладки.
 *      Вызывает функцию `debug_string_print_binary`.
 *
 * @param   str     строка сопровождения; 
 * @param   input   входное число.
 **/ 
void debug_print_binary_long(const char* str, unsigned int input){
    /**
     * @var Ширина выводимого числа.
     *      Нужна для дополнения его ведущеми нулями.
     */ 
    unsigned short width = sizeof(input) * 8;
    debug_string_print_binary(str, input, width);
}

/**
 * @fn  Выводит на поток ошибок число `input` в двоичном представлении.
 *      В этой программе нужна исключительно для отладки.
 *      Вызывает функцию `debug_string_print_binary`.
 *
 * @param   str     строка сопровождения; 
 * @param   input   входное число.
 **/ 
void debug_print_binary_byte(const char* str, unsigned short input){
    /**
     * @var Ширина выводимого числа.
     *      Нужна для дополнения его ведущеми нулями.
     */ 
    unsigned short width = 8;
    debug_string_print_binary(str, input, width);
}
