#!/usr/bin/env escript
%% -*- erlang -*-
%%! -smp enable -sname decoder
%%
%%  Простая и быстрая программа перевода 95-ичных пар входного потока,
%%  в байты выходного потока. На вход подаются строка, например:
%%       2I1z2I1_2J1X2J1a0W2I1}2I1_2J1X0A
%%  В результате работы программы она будет переведена в строку 
%%      `Миру мир!`.
%%  WARNING:
%%      Не пытайтесь дословно воспроизвести всю логику в программе на Си.
%%      Erlang имеет иную парадигму программирования. 
%%      В отличие от Си он основан не на машине фон Неймана.
%%      Однако, на уровне идеи логика будет сходной.
%%

-define(BASE, 95).

main(_) ->
    % Считываем 32768 символа (32 КиБ).
    % На самом деле тут все равно сколько считывать.
    % Но удобнее, если это число будет кратно количеству байт, 
    % представляющих закодированный символ.
    case io:get_chars('', 32768) of
        eof -> 
            % Если это конец файла, останавливаем программу.
            init:stop();
        "\n" ->
            % Если это перевод строки, то ничего не делаем,
            % просто повторяем итерацию.
            main([]);
        Input ->
            % Иначе разберем входную строку вручную, 
            % и получим перекодированную строку.
            Output = parse(Input),
            % Выведем строку как строку.
            io:format("~s", [Output]),
            % Повторяем итерацию.
            main([])
    end.

%%
%% @doc Разбирает входной список символов и декодирует его.
%% @spec parse(list()) -> list().
%%
parse(List) ->
    parse(List, []).

%%
%% @doc Разбирает входной список символов и декодирует его.
%%      Первый параметр это входной список, 
%%      во втором параметре накапливаются значения выходного списка.
%%      Функция состоит из трех уравнений.
%%          *   Первое уравнение срабатывает если входной список пуст 
%%              (т.е. мы уже все разобрали). Тогда просто возвращаем выходной 
%%              список, предварительно перевернув его.
%%          *   Второе уравнение срабатывает, если мы встретили символ 
%%              перевода строки. Тогда откусываем, этот символ 
%%              от входного списка, во входной список следующей итерации 
%%              кладем то, что осталось, а выходной список 
%%              оставляем без изменения.
%%          *   Третье уравнение срабатывает, когда во входном списке есть,
%%              восемь символов. Откусываем от входного списка восемь элементов,
%%              кладем, что осталось во входной список следующей итерации.
%%              Вычисляем результирующий символ по схеме Горнера 
%%              и добавляем его в начало выходного списка.
%% @spec parse(list(), list()) -> list().
%%
parse([], Acc) ->
    lists:reverse(Acc);

parse([$\n| Rest], Acc) ->
    parse(Rest, Acc);

parse([X1,X2| Rest], Acc) ->
    % Вычислим многочлен по основанию BASE по схеме Горнера.
    Number = ((convert(X1) * ?BASE) + convert(X2)),
    parse(
        Rest, % Остаток входного списка.
        [Number|Acc] % Добавка к выходному списку.
    ).

%%
%% @doc Переводит символ в число.
%%      Просто отнимаем от входного символа код символа 
%%      в зависимости от диапазона входного символа.
%% @spec convert(integer()) -> integer()
%% 
convert(X) when $0 =< X, X =< $9 ->
    X - $0;
    
convert(X) when $A =< X, X =< $Z ->
    X - $A + 10;

convert(X) when $a =< X, X =< $z ->
    X - $a + 36;

convert(X) when 32 =< X, X =< $/ ->
    X - 32 + 62;

convert(X) when $: =< X, X =< $@ ->
    X - $: + 78;

convert(X) when $[ =< X, X =< $` ->
    X - $[ + 85;

convert(X) when ${ =< X, X =< $~ ->
    X - ${ + 91;

convert(_) ->
    % Если ни один из вариантов не срабатывает.
    0.