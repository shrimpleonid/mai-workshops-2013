
/** 
 * @section ЗАДАЧА
 *
 *      Составить и отладить программу на языке Си, которая считает число
 *      со стандартного потока ввода (stdin), проверяет 
 *      есть ли соседние слова, состоящие из одного и того же набора букв.
 *      выводит результат на стандартный файл (поток) вывода (stdout).
 *
 *      @subsection Сборка
 *          $> gcc -Wall -pedantic -std=c89 ./programm.c
 * 
 *  @authors    Ганиев Дмитрий Юрьевич (студент 8O-101Б МАИ, 2013)
 *              Никитин Илья Константинович (преп. каф. 806 МАИ) <w@w-495.ru>
 * 
 *  @version    1.2
 */

/*
 * Подключаем заголовочный файл стандартного ввода-вывода 
 * (STanDart Input-Output) для использования getchar, putchar, scanf, printf.
 */
#include <stdio.h>

/*
 * Подключаем заголовочный файл `ctype.h` для использования функции `tolower`.
 * Вообще можно было бы эту функцию написать самостоятельно.
 */
#include <ctype.h>

/**
 * @consts  Введем логический тип с помощью констант.
 */
const int TRUE = 1, FALSE = 0;

/**
 * @fn  Преобразует символ во множество. 
 *      Принимает символ, возвращает "множество". 'c' -> {`c`}. 
 *      Множество, представлено в виде битовых полей.
 *      Битовое поле конкретного символа получают с помощью двоичного 
 *      сдвига беззнаковой единицы (`1u`) влево, 
 *      на количество разрядов равное номеру символа в алфавите (x - 'a').
 */
unsigned int char_to_set(char c) {
    unsigned int x = tolower(c);

    if (('a' <= x) && (x <= 'z'))
        return 1u << (x - 'a');
    else
        return 0;
}

int main() {

    int c = 0;
    int flag = FALSE;
    unsigned int prev_letters = 0;
    unsigned int curr_letters = 0;


    while (EOF != (c = getchar())) {
        /*
         * Вычисляем множество от символа `c`.
         */
        unsigned int c_set = char_to_set(c);

        /*
         * Применяем "дизъюнкцию" между множеством символов на предыдущем шаге
         * и множеством из входного символа `c`.
         */
        curr_letters = curr_letters | c_set;

        /*
         * Если очередной символ не является буквой  
         * (т. е. он дал пустое множество == `0`), 
         * но при этом было прочитано хотя бы одно слово (`0 != curr_letters`).
         * 
         */
        if (0 == c_set && 0 != curr_letters) {
            /*
             * Множества букв слов совпало.
             * Выставляем флаг в `TRUE`.
             */
            if (curr_letters == prev_letters) {
                flag = TRUE;

                /*
                 * Искомые слова есть. 
                 * Поиск дальше можно не продолжать.
                 * В данном случае мы можем разорвать цикл, 
                 * с помощью инструкции
                 *      `break;`
                 * 
                 * ЗАМЕЧАНИЕ:
                 *      Данный подход противоречит теореме Бойма-Якопини-Милса.
                 *      Но в данном случае теоремой можно пренебречь.
                 */
            }

            /*
             * Слово текущее на этом шаге цикла, станет предыдущим 
             * на следующем шаге. Тоже самое происходит с множествами.
             */
            prev_letters = curr_letters;

            /*
             * Обнуляем множество букв текущего слова, 
             * чтобы начать его заполнение  на следующем шаге.
             */
            curr_letters = 0;
        }
    }

    /*
     * Выводим число, используя тренарный оператор.
     */
    flag == TRUE ? printf("true\n") : printf("false\n");

    return 0;
}

