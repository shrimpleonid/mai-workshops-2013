/** **************************************************************************
 * 
 *  @mainpage Определяет есть ли во входном потоке символы 'e', 'o', 'u', 'y'.
 * 
 *  @section ЗАДАЧА
 *      Требуется ответит на вопрос, есть ли во входном потоке 
 *      символы 'e', 'o', 'u', 'y'. Если есть, то вывести 
 *      в выходной поток "Yes.", в противном случае вывести "No." 
 *      Задачу нужно решить с помощью битовых полей ("множеств").
 * 
 *  @section ОПИСАНИЕ
 * 
 *      Принимает на вход (в `stdin`) любую последовательность символов.
 *      Ввод завершается символом конца файла `EOF`.
 *      Результат, согласно задаче, выводится в стандартный поток 
 *      выхода (`stdout`). Работа осуществляется исключительно 
 *      с латинским алфавитом. Регистр букв игнорируется. 
 *      Символы не являющиеся буквами латинского алфавита игнорируются.
 *      Пример работы программы:
 *
 *          $> gcc -Wall -pedantic -ansi sets.c 
 *          $> ./a.out 
 *          qwerty
 *          Yes.
 *          $> ./a.out 
 *          qoqoqoqooosdsdsdsdsd
 *          Yes.
 *          $> ./a.out 
 *          ghfdhs 
 *          sdrt
 *          No.
 *          $> 
 * 
 *      @subsection АЛГОРИТМ
 *
 *          До начала работы программы, на этапе компиляции, 
 *          вычисляются битовое поля над символами 'e', 'o', 'u', 'y'.
 *          Делается это с помощью двоичного сдвига беззнаковой единицы (`1u`)
 *          влево, на количество разрядов равное номеру символа в алфавите.
 *          Далее вычисляется дизъюнкция (битовое "или") 
 *          над полученными битовыми полями. 
 *          В итоге получается целевое множество
 *          Во время работы программы битовые поля вычисляются 
 *          для каждой введенной буквы латинского алфавита 
 *          и с помощью дизъюнкции конструируется множество входных символов.
 *          Далее, вычисляется конъюнкция (битовое "и") 
 *          над целевым множеством и множество входных символов.
 *          Если в результате конъюнкции получилось на пустое множество,
 *          то в стандартный поток вывода печатается "Yes".
 * 
 *  @section ЛИЦЕНЗИЯ (BSD)
 *      © 2013 Илья w-495 Никитин, кафедра 806, МАИ.
 *      Разрешается повторное распространение и использование как
 *      в виде исходного кода, так и в двоичной форме,
 *      с изменениями или без, при соблюдении следующих условий:
 *          *   при повторном распространении исходного кода должно оставаться
 *              указанное выше уведомление об авторском праве,
 *              этот список условий и последующий отказ от гарантий;
 *          *   при повторном распространении двоичного кода должна
 *              сохраняться указанная выше информация об авторском праве,
 *              этот список условий и последующий отказ от гарантий
 *              в документации и/или в других материалах,
 *              поставляемых при распространении;
 *          *   ни название организации, ни имена ее сотрудников
 *              не могут быть использованы в качестве поддержки
 *              или продвижения продуктов, основанных на этом ПО
 *              без предварительного письменного разрешения.
 *      Эта программа предоставлена владельцами авторских прав и/или
 *      другими сторонами «как она есть» без какого-либо вида гарантий,
 *      выраженных явно или подразумеваемых, включая, но не ограничиваясь ими,
 *      подразумеваемые гарантии коммерческой ценности и пригодности
 *      для конкретной цели. Ни в коем случае ни один владелец авторских
 *      прав и ни одно другое лицо, которое может изменять и/или повторно
 *      распространять программу, как было сказано выше,
 *      не несёт ответственности, включая любые общие,
 *      случайные, специальные или последовавшие убытки,
 *      вследствие использования или невозможности использования программы
 *      (включая, но не ограничиваясь потерей данных, или данными,
 *      ставшими неправильными, или потерями принесенными из-за вас
 *      или третьих лиц, или отказом программы работать совместно
 *      с другими программами), даже если такой владелец
 *      или другое лицо были извещены о возможности таких убытков.
 *
 *  @package sets
 *      Основной модуль программы.
 * 
 *  @author     Илья w-495 Никитин <w@w-495.ru>
 *  @date       2013.11.18 01:50:44
 *  @version    1.1
 *
 * *************************************************************************/

/**
 * Подключаем для использования printf и getchar.
 */ 
#include<stdio.h>

/**
 * Подключаем для использования tolower.
 */ 
#include<ctype.h>

/**
 * @typedef Тип данных множество. 
 * В Си его нет, потому введем его сами.
 */
typedef unsigned int set_t;

/**
 * @var Директива препроцессора. Целевое множество.
 * 
 * {`e`} = 
 *       = 16 [10] =
 *       = 0000000000000000000000000000000000000000000000000000000000010000 [2]
 * 
 * {`o`} = 
 *       = 16384 [10] =
 *       = 0000000000000000000000000000000000000000000000000100000000000000 [2]
 * 
 * {`u`} = 
 *       = 1048576 [10] =
 *       = 0000000000000000000000000000000000000000000100000000000000000000 [2]
 * 
 * {`y`} = 
 *       = 16777216 [10] =
 *       = 0000000000000000000000000000000000000001000000000000000000000000 [2]
 * 
 * {`e`, `o`, `u`, `y` } = 
 *       = {`e`} ∨ {`o`} ∨ {`u`} ∨ {`y`} =
 *       = {`e`} | {`o`} | {`u`} | {`y`} =
 *       = 17842192 [10] =
 *       = 0000000000000000000000000000000000000001000100000100000000010000 [2]
 * 
 * Операция `|` (битовое "или") в данном случае выступает 
 * в качестве операции дизъюнкции.
 * 
 */ 
#define TARGET_SET (  (1u << ('e' - 'a')) \
                     |(1u << ('o' - 'a')) \
                     |(1u << ('u' - 'a')) \
                     |(1u << ('y' - 'a')) \
                   )
/**
 * @var Директива препроцессора. Пустое множество.
 */ 
#define EMPTY_SET 0

/**
 * @fn Преобразует символ во множество. Принимает символ, возвращает множество.
 * 'c' -> {`c`}
 */ 
set_t char2set(char);

int main  (){
    /**
     * @var Символ для обработки входного потока.
     */ 
    char c = 0;
    /**
     * @var Множества символов входного потока.
     * В начальный момент оно пусто.
     */ 
    set_t inputset = EMPTY_SET;
    /* Читаем до конца файла. */ 
    while( EOF != (c = getchar())){
        /**
         * Применяем "дизъюнкцию" между множеством символов на предыдущем шаге
         * и множеством из входного символа `c`.
         */
        inputset = inputset | char2set(c);
    }

    /**
     * Если хотя бы один символ целевого множества есть во входном множестве,
     * то тогда "конъюнкция" этих множеств будет не пустой.
     * В противном случае мы получим пустое множество.
     * В качестве конъюнкции в используется операция `&` (битовое "и").
     */ 
    if(inputset & TARGET_SET){
        printf("Yes.\n");
    }
    else{
        printf("No.\n");
    }
    return 0;
}

/**
 * @fn Преобразует символ во множество. Принимает символ, возвращает множество.
 * 'c' -> {`c`}
 */
set_t char2set(char c){
    /*
     * Приводим символ к нижнему регистру.
     */ 
    char lc = tolower(c);
    /*
     * Если символ является буквой, то преобразуем его во множество,
     * с помощью битовой маски. Если нет, то возвращаем пустое множество.
     */ 
    if( ('a' <= lc) && (lc <= 'z') ){
        return 1u << (lc - 'a');
    }
    return EMPTY_SET;
}