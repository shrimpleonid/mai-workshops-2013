
/**
 * @section ЗАДАЧА
 *
 *      Составить программу на Си, которая печатает таблицу 
 *      значений элементарной функции, вычисленной двумя способами: 
 *      по формуле Тейлора и с помощью встроенных функций. 
 *      В качестве аргументов таблицы взять точки разбиения отрезка [a, b]
 *      на n равных частей (n + 1 точка, включая концы отрезка), 
 *      находящихся в рекомендованной области хорошей точности формулы Тейлора. 
 *      Вычисления по формуле Тейлора проводить по экономной схеме 
 *      с точностью ε × k, где ε — машинное эпсилон аппаратно реализованного 
 *      вещественного типа для данной ЭВМ, а 
 *      k — экспериментально подбираемый коэффициент, 
 *      обеспечивающий приемлемую сходимость. 
 *      Число итераций должно ограничиваться сверху числом порядка 100. 
 * 
 *      Программа должна сама определять машинное ε 
 *      и обеспечивать корректные размеры генерируемой таблицы.
 * 
 * @section ОПИСАНИЕ
 * 
 *      Программа со стандартного входного потока-файла (stdin) 
 *      считывает число интервалов, на которые требуется разделить отрезок.
 *      В стандартный выходной поток-файл (stdout) печатается количество шагов,
 *      смещение по `x`, величина машинного эпсилона, ширина дробной части 
 *      машинного эпсилона, и таблица значений функций как указано в задании.
 *
 *          $> gcc -Wall -pedantic -std=c89  -lm  cp3example.c 
 *          $> ./a.out 
 *          10
 *                   x               сумма ряда        значение ф-ии   число 
 *                                                                    итераций
 *          0.0000000000000000 -1.6666666666666665 -1.6666666666666667   1
 *          0.0500000000000000 -1.7305973508230452 -1.7305976806422834   5
 *          0.1000000000000000 -1.8007651714677639 -1.8007662835249043   6
 *          0.1500000000000000 -1.8782246726562501 -1.8782249742002064   8
 *          0.2000000000000000 -1.9642850742671338 -1.9642857142857142   9
 *          0.2500000000000000 -2.0606047890285590 -2.0606060606060606  10
 *          0.3000000000000000 -2.1693114101100006 -2.1693121693121689  12
 *          0.3500000000000000 -2.2931778827404523 -2.2931785195936136  14
 *          0.4000000000000000 -2.4358967200695454 -2.4358974358974357  16
 *          0.4500000000000000 -2.6024945026436588 -2.6024955436720143  18
 *          0.4999999999999999 -2.7999990463256830 -2.7999999999999994  21
 *  
 *  @authors    Ганиев Дмитрий Юрьевич (студент 8O-101Б МАИ, 2013)
 *              Никитин Илья Константинович (преп. каф. 806 МАИ) <w@w-495.ru>
 * 
 *  @version    1.1
**/

/*
 * Подключаем заголовочный файл стандартного ввода-вывода 
 * (STanDart Input-Output) для использования getchar, putchar, scanf, printf.
 */
#include <stdio.h>

/*
 * Подключаем заголовочный файл libm для использования функции `pow`, 
 * `log10`, `ceil`. Но компилировать в этом случае придется с ключом -lm
 *      $> gcc -Wall -pedantic -std=c89 -lm ./programm.c
 */
#include <math.h>

/**
 * @typedef Тип данных работы с функциями на отрезке.
 *          Удобно менять с `double` на `float`, 
 *          и смотреть как меняются результаты.
 *          Например, становится легко видеть, 
 *          что для `double` и для  `float` машинный эпсилон разный!
 *          Менять придется только здесь, не трогая остальной программы.
 */
typedef double point_t;

/**
 * Формат ввода-вывода значений функции в точке и самой точки.
 * Вместо `f` можно было бы использовать `g` или `lf`.
 */
#define PR_FLOAT "f"

/**
 * Коэффициент сходимости. Подбирался экспериментально.
 */
const point_t K = 6000000000.0;

/**
 * Начало и конец интервала вычисления.
 */
const point_t A = 0.0, B = 0.5;

/**
 * @fn  Приводит число  к 64-битам, 
 *      на случай 80-битового вещественного регистра.
 *      Требуется для правильного вычисления epsylone().
 *      См комментарий на http://k806.ru/infocourse/task3/
 */
point_t function(point_t x) {
    return x;
}

/**
 * @fn Вычисляет и возвращает машинное эпсилон.
 */
point_t epsilon() {
    point_t eps = 1.0;
    while (function(eps / 2.0 + 1) > 1)
        eps = eps / 2.0;
    return eps;
}

int main() {

    /**
     * @var Машинное эпсилон.
     */
    point_t eps = epsilon();

    /**
     * @var Точка, в которой будут вычисляться приближенная и целевая функции.
     */ 
    point_t x;

    /**
     * @var Для хранения значения целевой функции.
     */ 
    point_t func;
    
    /**
     * @var Для хранения значения приближенной функции.
     */ 
    point_t tailor;
    
    /**
     * @var Размер шага по прямой `x`.
     */ 
    point_t step;

    /**
     * @var Количество интервалов, на которые мы делим отрезок.
     */
    int n;

    /**
     * @var Номер итераций при вычислении ряда Тейлора.
     */ 
    int iter;

    /**  
     * @var Ширина машинного эпсилон, 
     *      т.е. сколько десятичных знаков после запятой занимает эпсилон
     *      при печати. Переменная нужна только для красивого вывода на экран.
     */
    int width = ceil(-log10(eps));

    /*
     * Считываем количество шагов.
     */
    scanf("%d", &n);

    /*
     * Вычисляем размер шага, смещение точки на каждом шаге.
     */
    step = (B - A) / n;

    /*
     * Выводим шапку таблицы.
     * Количество пробелов подобрано экспериментально.
     */
    printf( 
        "         x                   "
        "сумма ряда              "
        "значение ф-ии   "
        "число итераций\n"
    );

    /*
     * Цикл по отрезку.
     */ 
    x = A;
    while (x <= B) {
        /*
         * Целевая функция.
         */ 
        func = (3.0 * x - 5.0) / (pow(x, 2) - 4.0 * x + 3.0);

        /*
         * Вначале сумма ряда Тейлора равна нулю.
         */ 
        tailor = 0.0;
        iter = 0;

        /*
         * Итерации по Тейлору.
         *      ЗАМЕЧАНИЕ:
         *          Цикл и итерации отличаются тем, что для цикла до его начала
         *          известно число шагов, в нашем случае это `n`.
         *          Для итеративного процесса число итераций не известно 
         *          с самого начала, и может меняться в зависимости от данных,
         *          которые меняются в результате самих итераций.
         *          В нашем случае это `fabs(func - tailor) >= eps * K`.
         */ 
        while (fabs(func - tailor) >= eps * K) {
            /*
             * Складываем член ряда Тейлора с результатами предыдущих сложений.
             */ 
            tailor += (-((1.0 + 2.0 / (pow(3.0, iter + 1))) * (pow(x, iter))));
            ++iter;
        }

        /*
         * Выводим строку таблицы.
         * Через `*` в printf указывается длина дробной части .
         * Для 64-битного point_t (double) 
         * длина дробной части машинного эпсилон равна 16.
         * Для 32-битного point_t (float) 
         * длина дробной части машинного эпсилон равна 7.
         */
        printf(
            "%.*"      PR_FLOAT
            "\t%.*"    PR_FLOAT
            "\t%.*"    PR_FLOAT
            "\t%3d\n", 
            width, x, 
            width, tailor, 
            width, func, 
            iter
        );

        /*
         * Увеличиваем `x` на величину шага.
         */
        x += step;
    }
    return 0;
}
