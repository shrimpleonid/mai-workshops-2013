/**
 * @section ЗАДАЧА
 * 
 *      Составить программу на языке Си, производящую обработку
 *      квадратной матрицы порядка NxN (0 <= N <= 512), из целых чисел,
 *      вводимой из стандартного входного текстового файла (stdin).
 *      Результат программы выводится на стандартный поток вывода (stdout).
 *
 *      В данном варианте требуется выполнить сложение всех строк, 
 *      содержащих максимальный элемент матрицы, 
 *      и замена первой из них на результат сложения.
 * 
 *      Формат ввода имеет вид:
 *
 *          {N}
 *          {x_11}  {x_21}  ... {x_1N} 
 *          {x_12}  {x_22}  ... {x_2N}
 *                          ...
 *          {x_N1}  {x_N2}  ... {x_NN}
 *
 *          Где, N --- размер матрицы.
 *
 *          ПРИМЕР:
 * 
 *              $> gcc -Wall -pedantic -std=c89 ./programm.c 
 *              $> ./a.out > result.txt
 *              3
 *              1 1 1
 *              1 2 1
 *              1 2 1
 *              $> cat result.txt
 *              1 1 1 
 *              2 4 2 
 *              1 2 1 
 *              $> 
 *
 * 
 *  @authors    Ганиев Дмитрий Юрьевич (студент 8O-101Б МАИ, 2013)
 *              Никитин Илья Константинович (преп. каф. 806 МАИ) <w@w-495.ru>
 * 
 *  @version    1.1
 */ 

/*
 * Подключаем заголовочный файл стандартного ввода-вывода 
 * (STanDart Input-Output) для использования getchar, putchar, scanf, printf.
 */
#include <stdio.h>

/**
 * @const Максимальный размер матрицы.
 */ 
#define MAX_MATRIX_SIZE 666

/**
 * @typedef Логический тип данных. 
 *          В Си его нет, потому введем его сами, 
 *          чтобы работать не с нулями и единицами,
 *          а c нормальными логическими значениями.
 *          Тут можно было бы использовать `stdbool.h` 
 *          и использовать встроенный тип `bool`.
 *          Но этот тип не поддерживается стандартом c89.
 */
typedef enum {FALSE, TRUE} flag_t;


int main() {

    /**
     * @var Рабочая матрица.
     */ 
    int a[MAX_MATRIX_SIZE][MAX_MATRIX_SIZE];

    /**
     * @var Вектор сумм строк матрицы с максимальными элементами.
     */ 
    int b[MAX_MATRIX_SIZE];

    /**
     * @var Размер матрицы.
     *      В качестве типа можно использовать int.
     *      Но `size` у нас по заданию ограничен и достаточно мал.
     *      Потому можно ограничится `short`.
     */ 
    short size;

    /**
     * @vars Переменные для индексов строк и столбцов.
     */ 
    short i, j, k;

    /**
     * @var Максимальный элемент матрицы.
     */ 
    int max;

    /**
     * @var Флаг наличия максимального элемента в строке.
     */ 
    flag_t hasmax;

    /**
     * @var Индекс первой строки с максимальным элементом.
     */ 
    short firstmax = 0;

    /**
     * @var Флаг, что следующая строка с макс элементом, будет такой первой.
     *      Т. е. будет перезаписана суммой всех строк, 
     *      содержащих максимальный элемент матрицы.
     */ 
    flag_t isfirstmax = TRUE;

    /*
     * Инициализация вектора сумм строк матрицы с максимальными элементами.
     */ 
    for (i = 0; i != size; ++i)
        b[i] = 0;

    /*
     * Считываем размер матрицы и величину сдвига.
     */
    scanf("%hd", &size);

    /*
     * Защита от дурака.
     */ 
    if (!((0 <= size) &&  (size <= MAX_MATRIX_SIZE))) {
        printf("wrong input\n");
        return 1;
    }

    /*
     * Cчитываем саму матрицу.
     */ 
    for (i = 0; i != size; ++i)
        for (j = 0; j != size; ++j)
            scanf("%d", &a[i][j]);

    /*
     * Поиск максимального элемента матрицы.
     */
    max = a[0][0];
    for (i = 0; i != size; ++i)
        for (j = 0; j != size; ++j)
            if (a[i][j] > max)
                max = a[i][j];

    /*
     * Поиск строки с минимальным элементом. 
     */
    hasmax = FALSE;
    for (i = 0; i != size; ++i) {
        for (j = 0; j != size; ++j)
            if (max == a[i][j])
                hasmax = TRUE;

        /*
         * Сложение строки, содержащей максимальный элемент,
         * с вектором b. В векторе b уже хранятся результаты 
         * предыдущих сложений.
         */
        if (TRUE == hasmax){
            /*
             * Запоминаем первую такую строку.
             */ 
            if(TRUE == isfirstmax){
                firstmax = i;
                isfirstmax = FALSE;
            }
            for (k = 0; k != size; ++k)
                b[k] = b[k] + a[i][k];
        }
        hasmax = FALSE;
    }

    /*
     * Перезапись первой строки с максимальным элементом, 
     * суммой всех строк, содержащих максимальный элемент матрицы.
     */ 
    for (i = 0; i != size; ++i)
        a[firstmax][i] = b[i];

    /*
     * Вывод матрицы.
     */ 
    for (i = 0; i != size; ++i) {
        for (j = 0; j != size; ++j)
            printf("%d ", a[i][j]);
        printf("\n");
    }

    return 0;
}

