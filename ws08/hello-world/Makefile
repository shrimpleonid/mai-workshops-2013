## 
## Определим компилятор.
## 
CC=gcc

## 
## Зададим общие флаги.
## 
CC_FLAGS= -pedantic -std=c89 -ansi

## 
## Зададим флаги для препроцессирования.
## 
CC_CPP_FLAGS= -E $(CC_FLAGS)

## 
## Зададим флаги для трансляции в ассемблер.
## 
CC_ASM_FLAGS= -S $(CC_FLAGS)

## 
## Зададим флаги для получения объектного кода.
## 
CC_OBJ_FLAGS= -c $(CC_FLAGS)

## 
## Зададим флаги для получения исполняемого файла.
## Ставим -v для "болтливого режима".
## 
CC_EXE_FLAGS=$(CC_FLAGS)


NAME=hello-world

SRC=$(NAME).c
CPP=$(NAME).prep.c
ASM=$(NAME).s
OBJ=$(NAME).o
EXE=$(NAME)

all: $(CPP) $(ASM) $(OBJ) $(EXE)

##
## *.c -> *.prep.c
## Из исходного кода программы получается тоже код на Си,
## но с подстановкой всех define и включением всех заголовочных файлов.
##
с2cpp: $(CPP)

$(CPP): $(SRC)
	#
	# 	Препроцессирование.
	#
	$(CC) $(CC_CPP_FLAGS) $< -o $@

##
## *.prep.c -> *.s
## Из препроцессированного кода на Си получается код ассемблера.
##
cpp2asm: $(ASM)

$(ASM): $(CPP)
	#
	# 	Трансляция в ассемблер.
	#
	$(CC) $(CC_ASM_FLAGS) $< -o $@ 2> /dev/null

##
## *.s -> *.o
## Из кода ассемблера получается объектный файл.
## По сути он является исполняемым (в формате `ELF`, `COFF` или `MS EXE`), 
## но внешние библиотеки (например ввода-вывода) не подключены.
##
asm2obj: $(OBJ)

$(OBJ): $(ASM) 
	#
	# 	Aссемблирование (получение объектного кода).
	#
	$(CC) $(CC_OBJ_FLAGS) $< -o $@

##
## *.o -> *.exe
## Внешние библиотеки линкуются с объектным файлом.
## На выходе получается исполняемая программа.
##	
obj2exe: $(EXE)


$(EXE):	$(OBJ)
	#
	# 	Компоновка (сборка, линковка).
	#
	$(CC) $(CC_EXE_FLAGS) $< -o $@

clean:
	rm -f $(CPP) $(ASM) $(OBJ) $(EXE)

