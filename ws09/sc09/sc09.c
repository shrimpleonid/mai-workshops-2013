/** 
 * @section ЗАДАЧА
 *
 *      Составить и отладить программу на языке Си итеративного характера 
 *      с целочисленными рекуррентными соотношениями, 
 *      задающими некоторое регулярное движение точки 
 *      в целочисленной системе координат (i, j) 
 *      с дискретным временем k и динамическим параметром движения l.
 *      Начальные данные движения:
 *
 *          i_{0}   =   10, 
 *          j_{0}   =   20, 
 *          l_{0}   =   −1,
 *          i_{k+1} =   (
 *                          |max(i_{k}(k + 5), j_{k}(k + 6))| 
 *                          − |min(j_{k}(k + 7), l_{k}(k + 8))|
 *                      ) mod 20,
 *          j_{k+1} =   (3 − sign(i_{k} − j_{k})) 
 *                      ×   |min(
 *                              i_{k} × l_{k} + 5, 
 *                              j_{k} × l_{k} − 3, 
 *                              i_{k} × j_{k} + 6
 *                          )| mod 25 − 7,
 *          l_{k+1} =   i_{k} mod 10 + j_{k} mod 10 + l_{k} mod 10. 
 *
 *      Результатом работы программы выводится в следующем виде:
 *          попадание точки в указанную замкнутую область 
 *          не более чем за 50 шагов (вывести Yes или No); 
 *          на следующей строке значения координат i, j, 
 *          значение динамического параметра l на момент окончания движения; 
 *          время окончания движения (номер шага, 
 *          на котором движение было прекращено), 
 *          если точка попала в область, затем перевод строки.
 *
 *      @subsection Сборка
 *          $> gcc ./programm.c -Wall -pedantic -std=c89
 * 
 *      @subsection Примеры 
 *          Примеры выходных сообщений.
 *              Точка попала в область на 35-м шаге, 
 *              значения координат и динамического параметра 
 *              стали ра
 *                  $> gcc ./programm.c -Wall -pedantic -std=c89
 *                  $> ./a.out
 *                  Yes
 *                  −10 12 3 35
 *
 *              Точка не попала в область за 50 шагов, 
 *              значения координат и динамического параметра 
 *              стали равны 0, −1 и −7 соответственно:
 *
 *                  $> gcc ./programm.c -Wall -pedantic -std=c89вны −10, 12 и 3 соответственно:
 *
 *                  $> ./a.out
 *                  No
 *                  0 −1 −7
 * 
 *      @subsection Примеры 
 *          Операции div и mod определяются так: 
 *              a div b = ⌊a / b⌋, 
 *              a mod b = a − (a div b) × b.
 * 
 *  @authors    Ганиев Дмитрий Юрьевич (студент 8O-101Б МАИ, 2013)
 *              Никитин Илья Константинович (преп. каф. 806 МАИ) <w@w-495.ru>
 * 
 *  @version    2.1
 */


/*
 * Подключаем заголовочный файл стандартного ввода-вывода 
 * (STanDart Input-Output) для использования getchar, putchar, scanf, printf.
 */ 

#include <stdio.h>

/**
 * @const   Количество шагов.
 */
const int NSTEPS = 50;

/**
 * @const   Начальные условия.
 */
const int I0 = 10;
const int J0 = 20;
const int L0 = -1;

/**
 * @const   Параметры области.
 *          Квадрат с длиной стороны 10, 
 *          стороны квадрата параллельны осям координат, 
 *          центр квадрата в точке (10, −10).
 */
const int LEFT = 5;
const int RIGHT = 15;
const int UPPER = -5;
const int LOWER = -15;

/**
 * @const   Логические константы.
 */
const int TRUE = 1;
const int FALSE = 0;

/**
 * @fn  Вычисляет функцию `x div y`. 
 *      Правильный div должен вести себя так:
 *           10 div  3 =  3
 *          -10 div  3 = -4
 *           10 div -3 = -4
 *          -10 div -3 =  3
 */
int div(x, y) {
    int res;

    if (x * y >= 0)
        res = x / y;
    else
        res = x / y - 1;
    return res;
}

/**
 * @fn  Вычисляет x mod y = x − (x div y) × y. 
 */
int mod(x, y) {
    return x - div(x, y) * y;
}

/**
 * @fn  Вычисляет максимум от двух аргументов. 
 */
int max2(x, y) {
    int res;

    if (x > y)
        res = x;
    else
        res = y;
    return res;
}

/**
 * @fn  Вычисляет минимум от двух аргументов. 
 */
int min2(x, y) {
    int res;

    if (x < y)
        res = x;
    else
        res = y;
    return res;
}

/**
 * @fn  Вычисляет минимум от трех аргументов. 
 */
int min3(x, y, z) {
    int res;

    if (x < y && x < z)
        res = x;
    else if (y < z)
        res = y;
    else
        res = z;
    return res;
}

/**
 * @fn  Вычисляет функцию знака числа.
 */
int sign(x) {
    int res;

    if (x > 0)
        res = 1;
    else if (x < 0)
        res = -1;
    else
        res = 0;
    return res;
}

/**
 * @fn  Вычисляет модуль числа. 
 */
int abs(x) {
    int res;

    if (x < 0)
        res = (-1) * x;
    return res;
}

/**
 * @fn  Возвращает истинность факта попадания в область.
 *      Квадрат с длиной стороны 10, 
 *      стороны квадрата параллельны осям координат, 
 *      центр квадрата в точке (10, −10).
 * 
 */
int trfal(i, j) {
    int isnside;

    if (i <= LEFT || i >= RIGHT || j <= LOWER || j >= UPPER)
        isnside = FALSE;
    else
        isnside = TRUE;
    return isnside;
}

int main() {

    /**
     * @vars    Начальные условия.
     */
    int i = I0;
    int j = J0;
    int l = L0;

    /**
     * @vars    Временные переменные для сохранения промежуточных результатов.
     */
    int it = 0;
    int jt = 0;
    int lt = 0;

    /**
     * @var     Количество шагов.
     */
    int k = 1;

    /**
     * @var     Флаг попадания в область.
     */
    int isnside = FALSE;

    while ((FALSE == (isnside = trfal(i, j))) && (k <= NSTEPS)) {
        /*
         * Присваиваем вычисленные значения временным переменным,
         * чтобы не перезаписывать параметры до полного их вычисления.
         */
        it = mod((abs(max2(i * (k + 5), j * (k + 6)))
                  - abs(min2(j * (k + 7), l * (k + 8)))), 20);

        jt = (mod(((3 - sign(i - j))
                   * (abs(min3(i * l + 5, j * l - 3, i * j + 6)))), 25) - 7);
        lt = mod(i, 10) + mod(j, 10) + mod(l, 10);
        i = it;
        j = jt;
        l = lt;
        ++k;
    }

    if (TRUE == isnside) {
        printf("YES\n");
        printf("%d %d %d %d\n", i, j, l, k);
    }
    else {
        printf("NO\n");
        printf("%d %d %d\n", i, j, l);
    }

    return 0;
}

