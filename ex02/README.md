# Возможные билеты экзамена

## Билет 01

1.  Алгоритм КМП.
2.  Ссылочный тип.
3.  Степень дерева.

### Подсказки

>
> Степень дерева.
>

Дерево общего вида.
Рекурсивно найти узел с максимальной степенью (количество детей).
Это и будет степенью дерева.
Есть в лекциях.
Конкретная реализация зависит
от представления дерева общего вида.
А представлений может быть как минимум два:

* через двоичное дерево
— надо найти узел с максимальном количеством братьев,
родитель этого узла и будет узлом, степень которого равна степени дерева);
* через список (массив) указателей на детей в каждом узле
— просто найти узел с максимальным числом детей.


## Билет 02

1.  Таблица с прямым доступом.
2.  Деревья выражений.
3.  Написать программу сравнения линейных списков.

### Подсказки

>
> Таблица с прямым доступом.
>

Можно попробовать реализовать хеш.

>
> Написать программу сравнения линейных списков.
>

Очень просто. Идти по обоим спискам и сравнивать элементы.
Если известно, что списки реализованы на массиве,
то можно воспользоваться `memcmp`.


## Билет 03

1.  Очередь. Функциональная спецификация.
2.  Сортировка слиянием.
3.  Написать программу, вычисляющую глубину дерева.

### Подсказки

>
> Написать программу, вычисляющую глубину дерева.
>

В простейшем случае дерево двоичное.
Просто рекурсивный обход со счетчиком.


## Билет 04

1.  Выражения с помощью двоичного дерева.
2.  Турнирная сортировка.
3.  Написать программу, выполняющую реверс файла.

### Подсказки

>
> Написать программу, выполняющую реверс файла.
>

Есть три способа реализации:

* с помощью стека;
* рекурсивно;
* с помощью fseek.


#### С помощью стека

Записывать входные символы в стек до конца фала,
а потом доставать из стека и писать в выходной файл.
Это плохой вариант, ибо памяти может не хватить.
Но вариант простой и быстрый.
Если памяти не хватит, то мы об этом хотя бы можем узнать.


#### Рекурсивно

На псевдо-Си можно изобразить так:

```c
    void revers(FILE *I, FILE *O){
        if(feof(I))
            return;
        char c = fgetc(I);
        revers(I, O);
        fputc(c, O);
    }
```

Плюсы подхода, — он очень простой и будет работать еще быстрее.
Не нужно реализовывать свой стек, потому что используется системный.
А системный стек всего скорее работает еще быстрее, чем ваш собственный.

В итоге используется все та же память.
Символы входного фала буду храниться в переменных `c` на каждой итерации рекурсии.
Но системный стек может закончиться еще раньше чем память.
И мы об этом узнаем только благодаря падению программы.
На самом деле, есть иные способы перехватить это событие,
но нужно или писать на C++ или использовать системные сигналы UNIX.


#### C помощью fseek

Позиционироваться в конец входного файла и читать его с конца.
При каждом чтении менять позиции `fseek`, сдвигая ее к началу.
Сдвигать надо на 2 символа (1 прочитанный, 1 еще не прочитанный).
Такой способ будет работать на файла любого размера.
Но из-за того, что при каждом `fseek` нужно будет позиционироваться по диску,
то все происходить будет медленно.

Правда, этот недостаток уходит, если мы используем не HDD диски,
а твердотельные SSD. Там `fseek` тоже медленнее, чем прямое чтение,
но разница будет меньше.


## Билет 05

1.  Стек. Функциональная спецификация.
2.  Деревья поиска.
3.  Конкатенация трех файлов.

### Подсказки

>
> Конкатенация трех файлов.
>

Хотим конкатенировать файлы `А`, `В` и `С` в файл `Z`.
Самый простой вариант на bash:

```bash
    cat A B C > Z;
```

Другой вариант (псевдо-Си):

```c
    void concat(FILE* I, FILE* O){
        char c = 0;
        while(EOF !=(c = fgetc(I))){
            fputc(c, O);
        }
    }

    int main(){
        FILE* Z = fopen("Z", 'w');

        FILE* A = fopen("A", 'r');
        concat(A, Z);
        fclose(A);

        FILE* B = fopen("B", 'r');
        concat(B, Z);
        fclose(B);

        FILE* C = fopen("C", 'r');
        concat(C, Z);
        fclose(C);

        fclose(Z);
    }
```

То же самое можно реализовать с помощью `fgets\fputs`
или `fread\fwrite`. Только заранее нужно указать размер буфера.
С помощью `fread\fwrite` будет работать быстрее.

Кроме того, в этой задаче можно обойтись без файла `Z`.
А конкатенировать все в `A`. Для этого можно:

* переименовать `Z` в `A` после выполнения конкатенации.
* использовать временный файл, и в конце программы его содержимое «перелить» в `A`.
* дописать содержимое `В` и `С` в `A`, открыв файл на дозапись `FILE* A = fopen("A", 'a');`.


## Билет 06

1.  Очередь. Функциональная спецификация.
2.  Алгоритм Бойера — Мура.
3.  Удаление узлов двоичного дерева.

### Подсказки

>
> Удаление узлов двоичного дерева.
>

Есть в лекциях. И все это делали в ЛР.


## Билет 08

1.  Файл. Функциональная спецификация.
2.  Таблица с прямым доступом.
3.  Составить программу определения глубины дерева.

### Подсказки

>
> Таблица с прямым доступом.
>

Можно реализовать хеш.

>
> Составить программу определения глубины дерева.
>

В простейшем случае дерево двоичное.
Рекурсивный обход со счетчиком.


## Билет 10

1.  Ссылочный тип данных.
2.  Дерево выражений.
3.  Транспонировать матрицу, взятую из файла (решать методом слияния).

### Подсказки

>
> Транспонировать матрицу, взятую из файла (решать методом слияния).
>

Я не очень понимаю, причем тут метод слияния.
Возможно, имеется ввиду сведение задачи к рекурсивной.

    Матрица транспонирована, если все ее столбцы (строки) являются транспонированными.

Т.к. матрица в файле, то ходить по ней надо будет через `fseek`.
Формат матрицы вы можете задать, какой вам удобно.
Файл может быть не текстовым, если вам будет так удобнее с ним работать.



## Билет 11

1.  Представление дерева общего вида в ЭВМ.
2.  Алгоритм Рабина — Карпа.
3.  Реверс файла.

### Подсказки

>
> Представление дерева общего вида в ЭВМ.
>

Возможны 3 варианта:

* через двоичное дерево;
* через указателя на родителя;
* через список (массив) указателей на детей в каждом узле.

Способ зависит от решаемой задачи.


>
> Реверс файла.
>

Есть три способа реализации:

* с помощью стека;
* рекурсивно;
* с помощью fseek.

См. Билет 04.


## Билет 12

1.  Двоичное дерево. Функциональная спецификация.
2.  Адресный тип. Реализация полиморфизма в си, с помощью адресного типа.
3.  Написать программу конкатенации трех файлов.

### Подсказки

>
> Реализация полиморфизма в си, с помощью адресного типа.
>

Это про указатели произвольного типа `void*`.

>
> Написать программу конкатенации трех файлов.
>

См. Билет 05

## Билет 13

1.  Сбалансированные деревья поиска.
2.  Абстракции в языках программирования.
3.  Составить программу, вычисляющую выражение в обратной польской записи.

### Подсказки

>
> Составить программу, вычисляющую выражение в обратной польской записи.
>

Нужен стек.

1. Считываете числа и знаки операций.
2. Кладете в стек числа.
3. Если встретилась операция, то извлекаете из стека два последних числа,
применяете к ним операцию и результат кладете в стек.
4. После окончания входной строки (входного файла — EOF)
в стеке останется результат только вычислений.



## Билет 15

1.  Линейный список. Логическое описание.
2.  Процедурный тип данных. Реализация полиморфизма с помощью процедурного типа данных.
3.  Сортировка файла.

### Подсказки

>
> Линейный список. Логическое описание.
>

Внимательно смотрите, что такое «логическое описание»

>
> Процедурный тип данных. Реализация полиморфизма с помощью процедурного типа данных.
>

Смотрите КП прошлого семестра, где мы передавали функцию как параметр.

>
> Сортировка файла.
>

Сортировка слиянием. На «5» посмотрите какие еще есть внешние сортировки.


## Билет 18

1.  Очередь. Логическое описание и физическое представление на массиве.
2.  Модульное программирование. Реализация на Си.
3.  Составить программу прошивки бинарного дерева.

### Подсказки

>
> Составить программу прошивки бинарного дерева.
>

Есть в лекциях. Просто ходить по дерево рекурсивно, и перевешивать указатели.

