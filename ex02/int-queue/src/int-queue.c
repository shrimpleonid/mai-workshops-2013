/**
 *  Реализация очереди на целом типе данных.
 *
 *  @section ЗАДАНИЕ
 *
 *      Требуется дать логическое описание очереди на целом числе на языке Си.
 *          В качестве типа  данных --- целые числа меньше ULONG_MAX
 *              (проще всего , t --- десятичные цифры ),
 *          а в качестве носителя unsigned long int.
 *
 *  @section ОПИСАНИЕ
 *
 *      В данном случае реализована очередь
 *      для чисел от 0 - 7   т.е. 8-ая система счисления.
 *
 *  @subsection ПРИМЕР
 *
 *  $> gcc int-queue_t.c -Wall -pedantic -std=c89
 *  $> ./a.out
 *  + 0-> 0000000000000000000000000000000000000000000000000000000000000000 [3]
 *  + 1-> 0000000000000000000000000000000000000000000000000000000000001000 [6]
 *  + 2-> 0000000000000000000000000000000000000000000000000000000010001000 [9]
 *  + 3-> 0000000000000000000000000000000000000000000000000000011010001000 [12]
 *  + 4-> 0000000000000000000000000000000000000000000000000100011010001000 [15]
 *  + 5-> 0000000000000000000000000000000000000000000000101100011010001000 [18]
 *  + 6-> 0000000000000000000000000000000000000000000110101100011010001000 [21]
 *  + 7-> 0000000000000000000000000000000000000000111110101100011010001000 [24]
 *  + 0-> 0000000000000000000000000000000000000000111110101100011010001000 [27]
 *  + 1-> 0000000000000000000000000000000000001000111110101100011010001000 [30]
 *  + 2-> 0000000000000000000000000000000010001000111110101100011010001000 [33]
 *  + 3-> 0000000000000000000000000000011010001000111110101100011010001000 [36]
 *  + 4-> 0000000000000000000000000100011010001000111110101100011010001000 [39]
 *  + 5-> 0000000000000000000000101100011010001000111110101100011010001000 [42]
 *  + 6-> 0000000000000000000110101100011010001000111110101100011010001000 [45]
 *  + 7-> 0000000000000000111110101100011010001000111110101100011010001000 [48]
 *  + 0-> 0000000000000000111110101100011010001000111110101100011010001000 [51]
 *  + 1-> 0000000000001000111110101100011010001000111110101100011010001000 [54]
 *  + 2-> 0000000010001000111110101100011010001000111110101100011010001000 [57]
 *  + 3-> 0000011010001000111110101100011010001000111110101100011010001000 [60]
 *  + 4-> 0100011010001000111110101100011010001000111110101100011010001000 [63]
 *  ^ 0-> 0000100011010001000111110101100011010001000111110101100011010001 [60]
 *  ^ 1-> 0000000100011010001000111110101100011010001000111110101100011010 [57]
 *  ^ 2-> 0000000000100011010001000111110101100011010001000111110101100011 [54]
 *  ^ 3-> 0000000000000100011010001000111110101100011010001000111110101100 [51]
 *  ^ 4-> 0000000000000000100011010001000111110101100011010001000111110101 [48]
 *  ^ 5-> 0000000000000000000100011010001000111110101100011010001000111110 [45]
 *  ^ 6-> 0000000000000000000000100011010001000111110101100011010001000111 [42]
 *  ^ 7-> 0000000000000000000000000100011010001000111110101100011010001000 [39]
 *  ^ 0-> 0000000000000000000000000000100011010001000111110101100011010001 [36]
 *  ^ 1-> 0000000000000000000000000000000100011010001000111110101100011010 [33]
 *  ^ 2-> 0000000000000000000000000000000000100011010001000111110101100011 [30]
 *  ^ 3-> 0000000000000000000000000000000000000100011010001000111110101100 [27]
 *  ^ 4-> 0000000000000000000000000000000000000000100011010001000111110101 [24]
 *  ^ 5-> 0000000000000000000000000000000000000000000100011010001000111110 [21]
 *  ^ 6-> 0000000000000000000000000000000000000000000000100011010001000111 [18]
 *  ^ 7-> 0000000000000000000000000000000000000000000000000100011010001000 [15]
 *  ^ 0-> 0000000000000000000000000000000000000000000000000000100011010001 [12]
 *  ^ 1-> 0000000000000000000000000000000000000000000000000000000100011010 [9]
 *  ^ 2-> 0000000000000000000000000000000000000000000000000000000000100011 [6]
 *  ^ 3-> 0000000000000000000000000000000000000000000000000000000000000100 [3]
 *  ^ 4-> 0000000000000000000000000000000000000000000000000000000000000000 [0]
 *
 * @author   Александ Балес, студент 8o-101, 2014 год, МАИ ПМФ.
**/

#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <limits.h>

/**
 *  Тип данных для хранения в очереди
 */
typedef unsigned char queue_data_t;

#define QUEUE_DATA_BITSIZE 3

#define QUEUE_DATA_UNAR 7

/**
 *  Тип данных для самой очереди
 */
typedef unsigned long int queue_bits_t;

#define QUEUE_BITS_MAX_CAP 64


/**
 *  Тип данных самой очереди
 */
typedef struct {
    queue_bits_t bit_Q;
    size_t cur;
} queue_t;

void queue_init(queue_t * qq);
bool queue_push(queue_t * qq, queue_data_t);
bool queue_pop(queue_t * qq);
queue_data_t queue_top(const queue_t * qq);
void queue_destroy(queue_t * qq);

char* bits2bin(queue_bits_t i);


int main() {
    queue_t qq;
    size_t i;
    queue_init(&qq);

    for(i = 0; i != 21; ++i){
        queue_data_t a = i % 8;
        queue_push(&qq, a);
        fprintf(stderr, "+ %d -> %s [%lu]\n", a, bits2bin(qq.bit_Q), qq.cur);
    }

    for(i = 0; i != 21; ++i){
        queue_data_t a = queue_top(&qq);
        if(queue_pop(&qq)){
            fprintf(stderr, "- %d -> %s [%lu]\n", a, bits2bin(qq.bit_Q), qq.cur);
        }

    }
    queue_destroy(&qq);
    return 0;
}



void queue_init(queue_t * qq) {
    qq->cur = 0;
    qq->bit_Q = 0;
}

bool queue_push(queue_t * qq, queue_data_t x) {
    queue_bits_t t = x;
    if (qq->cur > QUEUE_BITS_MAX_CAP - QUEUE_DATA_BITSIZE)
        return false;
    t <<= qq->cur;
    qq->bit_Q |= t;
    qq->cur += QUEUE_DATA_BITSIZE;
    return true;
}

bool queue_pop(queue_t * qq) {
    if (!(qq->cur))
        return false;
    qq->bit_Q >>= QUEUE_DATA_BITSIZE;
    qq->cur -= QUEUE_DATA_BITSIZE;
    return true;
}

queue_data_t queue_top(const queue_t * qq) {
    if (qq->cur)
        return qq->bit_Q & QUEUE_DATA_UNAR;
    return -1;
}

void queue_destroy(queue_t * qq) {
    qq->cur = 0;
    qq->bit_Q = 0;
}

char* bits2bin(queue_bits_t i) {
    size_t bits = sizeof(queue_bits_t) * CHAR_BIT;
    char * str = malloc(bits + 1);
    queue_bits_t u;
    if(!str)
        return NULL;
    str[bits] = 0;
    u = *(queue_bits_t *)&i;
    for(; bits--; u >>= 1)
        str[bits] = u & 1 ? '1' : '0';
    return str;
}

