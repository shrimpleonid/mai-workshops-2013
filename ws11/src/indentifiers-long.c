/**
 * Требуется подсчитать количество слов — правильных идентификаторов языка Си.
 * Идентификаторы должны начинаться с букв латинского алфавита  
 * или знака подчеркивания, далее допускается использовать арабские цифры:
 * 
 *      Идентификатор = ( Буква | "_" ) { Буква | Цифра | "_" }  
 *      Буква = |"A"|"B"|...|"Y"|"Z"|"a"|"b"|...|"y"|"z"  
 *      Цифра = "0"|"1"|...|"9"  
**/

#include <stdio.h>

/**
 * @typedef Логический тип данных. 
 * В Си его нет, потому введем его сами, чтобы работать не с нулями и единицами,
 * а нормальными логическими значениями.
 */
typedef enum { FALSE = 0, TRUE = 1 } bool_t;

/*
 * Замечание:
 *      Сначала я объявил функции которые, мне всего скорее будут нужны.
 *      Опишу эти функции после `main`. Понятия не имею, что в них будет.
 *      Главное придумать правильную логику программы, 
 *      о деталях подумаем потом. Это подход сверху вниз.
 */

/**
 * @fn  Проверяет является ли символ `chr` буквой латинского алфавита.
 */
bool_t is_letter(char chr);

/**
 * @fn  Проверяет является ли символ `chr` буквой арабской десятичной цифрой.
 */
bool_t is_digit(char chr);

/**
 * @fn  Проверяет является ли символ `chr` началом идентификатора.
 */
bool_t is_identifier_start(char chr);

/**
 * @fn  Проверяет является ли символ `chr` символом внутри идентификатора.
 */
bool_t is_identifier_body(char chr);

/**
 * @fn  Выполняет основные действия программы. 
 *      Считывает данные из `stdin`, стандартного файла (потока) ввода.
 *      В `stdout`, стандартный поток (файл) вывода 
 *          выводит количество идентификаторов.
 */
int main(){
    /**
     * @var Переменная, которая хранит текущий символ.
     */
    char chr = 0;
    /**
     * @var Счетчик идентификаторов.
     */
    long identifier_counter = 0;
    /**
     * @var Флаг, который говорит, было ли начало идентификатора.
     */
    bool_t is_inside = FALSE;
    /**
     * @var Флаг, для обработки ложных идентификаторов типа `0zzz`.
     */
    bool_t is_fake = FALSE;

    /**
     * Считываем символ за символом до конца файла.
     */
    while (EOF != (chr = getchar())) {
        if (is_inside && !is_identifier_body(chr)) {
               /**
                * Встретили первый символ, который 
                * уже не является телом идентификатора.
                * Например:
                *      На первом шаге цикла (`^` --- значение `chr`):
                *      
                *          "int foo1;"
                *           ^
                *              =>  chr                      == 'i';
                *              =>  is_identifier_start(chr) == TRUE
                *              =>  is_inside                == TRUE;
                *      
                *      На предыдущем шаге цикла:
                *          "int foo1;"
                *                  ^
                *              =>  chr                      == '1';
                *              =>  is_identifier_start(chr) == FALSE;
                *              =>  is_inside                == TRUE ;
                *                   (т.к. на первом шаге проставили);
                *      
                *      На текущем шаге цикла:
                *          "int foo1;"
                *                   ^
                *              =>  chr                      == ';';
                *              =>  is_identifier_start(chr) == FALSE;
                *              =>  is_identifier_body(chr)  == FALSE;
                *              =>  !is_identifier_body(chr) == TRUE;
                *              =>  is_inside                == TRUE
                *                   (т.к. на первом шаге проставили);
                *
                *      Тогда мы говорим, что идентификатор закончился,
                *      и увеличиваем число идентификатором на 1.
                *  
                */
            is_inside = FALSE;
            is_fake = FALSE;
            ++identifier_counter;
        } else if (!is_fake && is_identifier_start(chr)) {
               /**
                * Встретили первый символ идентификатора.
                * Вне идентификатора. 
                * Условие if(!is_inside) опускаем.
                */
            is_inside = TRUE;
            is_fake = FALSE;
        } else if (!is_identifier_start(chr) && is_identifier_body(chr)) {
               /**
                * Обработка ложных случаев. 
                * Вне идентификатора.
                * Условие if(!is_inside) опускаем.
                * Символ не может быть началом идентификатора, 
                * но может встречаться в его теле.
                * 
                */
            is_inside = FALSE;
            is_fake = TRUE;
        } else if (!is_identifier_body(chr)) {
               /**
                * Обработка ложных случаев. 
                * Сейчас находимся Вне идентификатора.
                * Условие if(!is_inside) опускаем.
                * Встретили символ, который вообще не может встречаться
                * в идентификаторе.
                */
            is_inside = FALSE;
            is_fake = FALSE;
        }
    }
    /**
     * Выводим счетчик идентификаторов. 
     * Не забываем про конечный перевод строки.
     */
    printf("%ld\n", identifier_counter);
    return 0;
}

/*
 * Замечание:
 *      Напоследок опишу функции, которые объявил в самом начале.
 */

/**
 * @fn  Проверяет является ли символ `chr` началом идентификатора.
 */
bool_t is_identifier_start(char chr){
    if (is_letter(chr) || ('_' == chr))
        return TRUE;
    return FALSE;
}

/**
 * @fn  Проверяет является ли символ `chr` символом внутри идентификатора.
 */
bool_t is_identifier_body(char chr){
    if (is_letter(chr) || ('_' == chr) || is_digit(chr))
        return TRUE;
    return FALSE;
}

/**
 * @fn  Проверяет является ли символ `chr` буквой латинского алфавита.
 */
bool_t is_letter(char chr){
    if ((('A' <= chr) && (chr <= 'Z')) || (('a' <= chr) && (chr <= 'z')))
        return TRUE;
    return FALSE;
}

/**
 * @fn  Проверяет является ли символ `chr` буквой арабской десятичной цифрой.
 */
bool_t is_digit(char chr){
    if (('0' <= chr) && (chr <= '9'))
        return TRUE;
    return FALSE;
}
