/**
 * Импровизированный вариант "словаря", с пронумерованными словами.
 * Задача экзотичная. Начальная идея, как и автор не известны.
 * Хороший пример позиционирования внутри файла.
 * Словарь находится в файле `vaca.dat` на каждое слово отведено 10 байт.
 * Предполагается наличие трех "языков" с девятью "словами" каждый.
 * При запуске программы запрашивается язык (по номеру),
 * а после выбора языка, запрашивается номер слова.
 * На основании номера языка и слова, происходит позиционирование в файле.
 * Файл имеет такую структуру:
 *      <2 байта><слово 1 яз 1><слово 1 яз 2><слово 1 яз 3>
 *      <2 байта><слово 2 яз 1><слово 2 яз 2><слово 2 яз 3>
 *      и т.д.
 *
 * Каждое слово на конкретном языке занимает 10 байт.
 * Все слова, перевода друг друга на одном и том же языке,
 * с учетом разделителя занимают 32 байта.
 * Сам файл `vaca.dat` занимает 32 * 8 + 30 + 2 = 288 байт.
 */

#include <stdio.h>

#define FILE_NAME "vaca.dat"
#define WORD_SIZE 10


int main() {

    /**
     * @var Буфер для хранения слова.
     */
    char buffer[WORD_SIZE];

    /**
     * @var Номер языка.
     */
    short lang_num;

    /**
     * @var Файловый указатель
     */
    FILE *fp;

    /*
     * Открываем файл на чтение.
     * Если не получилось, ругаемся и выходим.
     */
    if ((fp = fopen(FILE_NAME, "r")) == NULL) {
        perror(FILE_NAME);
        return 1;
    }

    /*
     * Считываем номер языка.
     */
    puts("\n enter the language number (1/2/3, 0 - exit ):");
    scanf("%hd", &lang_num);
    if (0 == lang_num) {

        /*
         * Закрываем файл.
         * Это надо делать обязательно!
         */
        fclose(fp);
        return 0;
    }


    /*
     * В бесконечном цикле считываем номер слова,
     * и выводим само слово.
     */
    while (1) {

        /**
         * @var Номер слова.
         */
        short word_num;

        /**
         * @var Номер символа.
         */
        short char_num;

        /**
         * @var Указатель на позицию в буфере.
         */
        char *c = buffer;

        /**
         * @var Позиция в файле.
         */
        long seek_position;

        /*
         * Считываем номер слова.
         */
        puts("enter word number ( 0 - exit ):");
        scanf("%hd", &word_num);
        if (0 == word_num) {
            fclose(fp);
            return 0;
        }

        /*
         * Вычисляем куда позиционироваться в файле.
         * Файл имеет структуру такую:
         *      <2 байта><слово 1 яз 1><слово 1 яз 2><слово 1 яз 3>
         *      <2 байта><слово 2 яз 1><слово 2 яз 2><слово 2 яз 3>
         *      и т.д.
         *
         * Каждое слово на конкретном языке занимает 10 байт.
         * Все слова, перевода друг друга на одном и том же языке,
         * с учетом разделителя занимают 32 байта.
         */
        seek_position = 2 + (word_num - 1) * 32  + (lang_num - 1) * WORD_SIZE;

        /*
         * Позиционируемся в файле на `seek_position` байт, от начала файла.
         */
        fseek(fp, seek_position, SEEK_SET);

        /*
         * Проходим по файлу и записываем содержимое в буфер
         */
        for (char_num = 0; char_num != WORD_SIZE; ++char_num)
            *c++ = getc(fp);
        /*
         *  В конец буфера записываем символ конца строки
         */
        *c = '\0';

        /*
         * Выводим номер слова и его значение.
         */
        printf("%d->%s (%ld)\n", word_num, buffer, seek_position);
    }

    /*
     * Закрываем файл.
     * Это надо делать обязательно!
     */
    fclose(fp);
    return 0;
}
